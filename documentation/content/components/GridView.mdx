import {GridLayout, GridView} from '@react/react-spectrum/GridView';
import {LayoutSwitcher, renderItem, TestDS} from '../helpers/GridView';
import {renderEmptyView} from '../helpers/TableView';
import ListDataSource from '@react/react-spectrum/ListDataSource';

A **GridView** displays a list of content arranged in a grid layout, including fixed grid, waterfall (masonry), and
gallery (horizontal masonry) layouts. GridView works hand in hand with the [Card](/components/Card) component to display customizable items.
It supports many advanced features like infinite scrolling, drag and drop both into and out of the grid view, multiple 
selection, keyboard navigation, and more. It is designed to scale to collections of any size using a virtual scroller 
that only renders the currently visible items into the DOM.

## Example

<LayoutSwitcher />

```jsx
import {GridView} from '@react/react-spectrum/GridView';

<GridView
  layout={layout}
  dataSource={dataSource}
  renderItem={renderItem} />
```

See below for details about these props.

## Overview

To set up a GridView, a few pieces are required: the layout to use, a data source to provide the items to display,
and a `renderItem` function to render the UI for an individual item.

### Layouts

There are three layouts supported by GridView:

* A **fixed grid layout**, where every item is the same size.
* A **waterfall layout**, sometimes called a masonry, where the items are arranged into equal width columns but can have variable heights.
* A **gallery layout**, which is similar to a waterfall layout, but arranged horizontally into rows. In a gallery layout, both the 
  widths and heights are variable, and are adjusted automatically to ensure the items always fill all available space.

You can see all of these layouts in the example above. GridView supports switching the layout on demand and can perform an animated 
transition between the layouts as well.

Each of these layouts have several settings to control various aspects of the layout, such as minimum and maximum sizes, spacing information,
and more. However, there are some defaults defined by spectrum that most applications should use.

To control the layout, just pass the `layout` prop to the GridView. There are two ways:

1. If you just want the default settings, pass the constructor of the layout you want to use to the `layout` prop, 
   e.g. `layout={GalleryLayout}`.

   ```jsx
    import {GridView, GalleryLayout} from '@react/react-spectrum/GridView';

    <GridLayout
      {...otherProps}
      layout={GalleryLayout} />
   ```

2. If you want to override some layout settings, pass an instance of the layout to the `layout` prop, e.g. 
   `layout={this.layout}`. You should initialize `this.layout` in the constructor of your 
   component to avoid constructing a new instance on every render.

   ```jsx
    import {GridView, GalleryLayout} from '@react/react-spectrum/GridView';
    import React from 'react';

    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.layout = new GalleryLayout({
          idealRowHeight: 100
        });
      }

      render() {
        return (
          <GridLayout
            {...otherProps}
            layout={this.layout} />
        );
      }
    }
   ```

### Data Sources

A data source provides the data for a GridView to display, and responds to user initiated actions such as drag and drop.
Data sources can be shared across multiple types of views that display collections of data, e.g. TableView and GridView.
Data provided by a data source is two dimensional: items are grouped into sections. This can be useful, for example, if you 
want to display headers above a group of items.

There is a base class for data sources that can be used by GridView called [ListDataSource](/classes/ListDataSource), which supports asynchronous
loading of data, and infinite scrolling. To provide data, implement the `load` method and return the data for
the items you want to display. If you want to support infinite scrolling, implement the `loadMore` method as well.

```javascript
import ListDataSource from '@react/react-spectrum/ListDataSource';

class MyDataSource extends ListDataSource {
  async load() {
    // load some data here
    return [...];
  }

  async loadMore() {
    // load more data
    return [...];
  }
}
```

These methods support loading data in a single section. If you want to support multiple sections, you should override the
`performLoad` and `performLoadMore` methods instead to perform your own insertion logic to ensure items are grouped into the
correct sections.

When data in the data source changes, perhaps in response to some external event such as a server update, the data source 
should emit events. The grid view listens for these events and updates its views as necessary, optionally with an animation. 
There are helper methods as part of the base data source class that you can call to emit these events and update the data.
You can also use transactions to group multiple updates together into a single animation. See the [API docs](/classes/ListDataSource) for details.

### Item Renderers

The last required piece for a GridView is a `renderItem` prop, which is just a function to render the contents of a item.
It receives the data for the item to render. Typically, a [Card](/components/Card) component is used within a GridView.
The Card will automatically adjust to the correct variant and size based on the GridView layout that is applied.

```jsx
function renderItem(data) {
  return <Card>{...}</Card>;
}
```

## Selection

GridView supports multiple selection out of the box, typically displayed using checkboxes on each item. Selection is enabled by default, 
but you can disable it by setting the `allowsSelection` prop to `false`. If you want to only allow selecting one item at a time,
set `allowsMultipleSelection` to `false`.

To handle selection changes, you can use the `onSelectionChange` prop. This will be passed a list of `IndexPath` objects, which store
the indexes of the items that are currently selected. An `IndexPath` has `section` and `index` properties, which represent the indices 
in the two dimensional array of items provided by the data source.

To set the selection programmatically, provide the `selectedIndexPaths` prop to the GridView. This should be an array of `IndexPath` objects,
like the one passed to `onSelectionChange`.

```jsx
<GridView
  {...otherProps}
  selectedIndexPaths={[...]}
  onSelectionChange={(selectedIndexPaths) => {}} />
```

## Drag and Drop

GridView supports both dragging items from a grid view (a drag source), as well as dropping files or other objects into a grid view (a drop target).
It uses the native HTML5 drag and drop API, so it is easy to integrate with other drag and drop solutions that other components might use.
You can provide custom data to be passed with the drag, which will be received by the drop target, and provide a custom view to be
displayed under the cursor while dragging. Drops into a GridView can be between items (inserting into a list), onto an item (for example adding 
items into items representing folders), or onto the entire grid view (adding items into the current view). Items can also be optionally
reordered by enabling the `canReorderItems` prop.

The following example shows how items can be dragged from one GridView to another. Items on the right can also be reordered.

<div style={{display: 'flex', justifyContent: 'space-between'}}>
  <GridView
    layout={GridLayout}
    cardSize="S"
    dataSource={new TestDS}
    renderItem={renderItem}
    className="example-tableview"
    canDragItems />
  <GridView
    layout={GridLayout}
    cardSize="S"
    dataSource={new TestDS([])}
    renderItem={renderItem}
    className="example-tableview"
    acceptsDrops
    renderEmptyView={renderEmptyView}
    canReorderItems />
</div>


```jsx
<GridView
  layout={GridLayout}
  cardSize="S"
  dataSource={dataSource1}
  renderItem={renderItem}
  canDragItems />
<GridView
  layout={GridLayout}
  cardSize="S"
  dataSource={dataSource2}
  renderItem={renderItem}
  renderEmptyView={renderEmptyView}
  acceptsDrops
  canReorderItems />
```

### Drag Sources

To enable dragging items from a GridView, pass the `canDragItems` prop. This is all you need to do to enable basic support for dragging items.
If you want to customize how the drag and drop works, there are some additional functions you can override.

#### Customizing the drag view

By default, the entire item will be rendered under the cursor while dragging. To customize this, you can provide the `renderDragView` prop
to GridView to render any custom view you want. It is passed a drag target representing the item the user actually clicked and dragged from,
along with the selected index paths for all items that would be dragged.

```jsx
<GridView
  {...otherProps}
  renderDragView={(dragTarget, selectedIndexPaths) => <div>My custom drag view</div>} />
```

#### Customizing the drag data

By default, the selected item objects are serialized to JSON and passed along with the drag to the drop target. This will work
if the only drop targets you want to support are other GridViews or TableViews, but you may want to support a custom data format for your
content that will work across applications and frameworks. You can also provide data in multiple representations, so that many
different receiving applications can handle the drop. To do this, you can override the `prepareDragData` method of your
data source.

```javascript
class MyDataSource extends ListDataSource {
  // ...
  
  prepareDragData(dragTarget, dataTransfer, selectedIndexPaths) {
    // Add plain text representation
    dataTransfer.setData('text/plain', 'some text');

    // Add rich text representation
    dataTransfer.setData('text/html', '<strong>some bold text</strong>');

    // Add custom data
    dataTransfer.setData('my-custom-format', 'some data');
  }
}
```

### Drop Targets

To enable dropping files or other objects in a GridView, pass the `acceptsDrops` prop. This can be a boolean to accept all drops,
or a list of allowed drag types (e.g. `Files`, `text/plain` or your custom format name).

#### Handling drops

By default, GridView will handle drops from other GridViews or TableViews, but you may need to support dropping files or other custom types
of objects. To do this, you need to implement the `itemsForDrop` method on your data source. This method is passed a drop target
and the data transfer object from the drag, and should return items that should be dropped.

Once those items are chosen, they are inserted into the GridView as items automatically. If you want to do any custom handling,
e.g. uploading dropped files, or performing other custom logic, you can override the `performDrop` method.

```javascript
class MyDataSource extends ListDataSource {
  // ...
  
  itemsForDrop(dropTarget, dataTransfer) {
    // parse your custom format
    return JSON.parse(dataTransfer.getData('my-custom-format'));
  }

  performDrop(dropTarget, dropOperation, items) {
    // custom logic here
  }
}
```

#### Customizing the drop position

Items can be dropped in several different positions over a GridView. They can be inserted between items, dropped on top of items
(e.g. uploading into a folder), or dropped on top of the grid view itself (e.g. uploading into the current folder). To control this behavior,
pass either `"on"` or `"between"` to the `dropPosition` prop.

With `dropPosition="between"`, the dragged items are inserted as items before the target. This is indicated by a space opening up between the items.
If you drag past the last item in the grid view into the empty space, the items are inserted at the end.

With `dropPosition="on"`, the dragged items are dropped into the target. This is indicated by highlighting the target item with a blue outline.
If you drag past the last item, the items are dropped into the grid view as a whole. This is indicated by highlighting the entire grid view with a 
blue outline.

In order to get more fine grained control over this behavior, e.g. allowing drops on some items but not others, you can override 
the `getDropTarget` method of the data source to override the default target.

The following example shows how you might allow dropping onto folders but not files, e.g. in a file manager. Assuming `dropPosition="on"`
has already been set, the `getDropTarget` method is used to override the target return `null` if it is not a folder.

```javascript
class MyDataSource extends ListDataSource {
  // ...
  
  getDropTarget(target) {
    // Get the item object
    let item = this.sections[target.indexPath.section][target.indexPath.index];

    // If the item is a folder, allow dropping into it.
    if (item.type === 'folder') {
      return target;
    }

    // Otherwise, prevent the drop.
    return null;
  }
}
```

## Accessibility

GridView implements the aria grid design pattern. It handles multiselection, item focusing, and is fully keyboard accessibile out of the box.

## Internationalization

To internationalize a GridView, you should provide localized content to the items displayed in the grid. GridView itself has no content of its
own to localize.
